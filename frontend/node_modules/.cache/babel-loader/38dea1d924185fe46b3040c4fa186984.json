{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmosClient = exports.isSearchByTagsQuery = exports.isSearchBySentFromOrToQuery = exports.isSearchByHeightQuery = exports.assertIsBroadcastTxSuccess = exports.isBroadcastTxSuccess = exports.isBroadcastTxFailure = void 0;\n\nvar crypto_1 = require(\"@cosmjs/crypto\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar math_1 = require(\"@cosmjs/math\");\n\nvar lcdapi_1 = require(\"./lcdapi\");\n\nvar logs_1 = require(\"./logs\");\n\nfunction isBroadcastTxFailure(result) {\n  return !!result.code;\n}\n\nexports.isBroadcastTxFailure = isBroadcastTxFailure;\n\nfunction isBroadcastTxSuccess(result) {\n  return !isBroadcastTxFailure(result);\n}\n\nexports.isBroadcastTxSuccess = isBroadcastTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\n\nfunction assertIsBroadcastTxSuccess(result) {\n  if (isBroadcastTxFailure(result)) {\n    throw new Error(\"Error when broadcasting tx \".concat(result.transactionHash, \" at height \").concat(result.height, \". Code: \").concat(result.code, \"; Raw log: \").concat(result.rawLog));\n  }\n}\n\nexports.assertIsBroadcastTxSuccess = assertIsBroadcastTxSuccess;\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nexports.isSearchByHeightQuery = isSearchByHeightQuery;\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nexports.isSearchBySentFromOrToQuery = isSearchBySentFromOrToQuery;\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nexports.isSearchByTagsQuery = isSearchByTagsQuery;\n\nvar CosmosClient = /*#__PURE__*/function () {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the broadcastTx method returns\n   */\n  function CosmosClient(apiUrl) {\n    var broadcastMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lcdapi_1.BroadcastMode.Block;\n\n    _classCallCheck(this, CosmosClient);\n\n    this.lcdClient = lcdapi_1.LcdClient.withExtensions({\n      apiUrl: apiUrl,\n      broadcastMode: broadcastMode\n    }, lcdapi_1.setupAuthExtension);\n  }\n\n  _createClass(CosmosClient, [{\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, chainId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.chainId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.lcdClient.nodeInfo();\n\n              case 3:\n                response = _context.sent;\n                chainId = response.node_info.network;\n\n                if (chainId) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Chain ID must not be empty\");\n\n              case 7:\n                this.chainId = chainId;\n\n              case 8:\n                return _context.abrupt(\"return\", this.chainId);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getHeight\",\n    value: function () {\n      var _getHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$lcdClient, height, latest;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.anyValidAddress) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.lcdClient.auth.account(this.anyValidAddress);\n\n              case 3:\n                _yield$this$lcdClient = _context2.sent;\n                height = _yield$this$lcdClient.height;\n                return _context2.abrupt(\"return\", parseInt(height, 10));\n\n              case 8:\n                _context2.next = 10;\n                return this.lcdClient.blocksLatest();\n\n              case 10:\n                latest = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(latest.block.header.height, 10));\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getHeight() {\n        return _getHeight.apply(this, arguments);\n      }\n\n      return getHeight;\n    }()\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n\n  }, {\n    key: \"getIdentifier\",\n    value: function () {\n      var _getIdentifier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tx) {\n        var response, hash;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.lcdClient.encodeTx(tx);\n\n              case 2:\n                response = _context3.sent;\n                hash = crypto_1.sha256(encoding_1.fromBase64(response.tx));\n                return _context3.abrupt(\"return\", encoding_1.toHex(hash).toUpperCase());\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getIdentifier(_x) {\n        return _getIdentifier.apply(this, arguments);\n      }\n\n      return getIdentifier;\n    }()\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n\n  }, {\n    key: \"getSequence\",\n    value: function () {\n      var _getSequence = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getAccount(address);\n\n              case 2:\n                account = _context4.sent;\n\n                if (account) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n\n              case 5:\n                return _context4.abrupt(\"return\", {\n                  accountNumber: account.accountNumber,\n                  sequence: account.sequence\n                });\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getSequence(_x2) {\n        return _getSequence.apply(this, arguments);\n      }\n\n      return getSequence;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var account, value;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.lcdClient.auth.account(address);\n\n              case 2:\n                account = _context5.sent;\n                value = account.result.value;\n\n                if (!(value.address === \"\")) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 8:\n                this.anyValidAddress = value.address;\n                return _context5.abrupt(\"return\", {\n                  address: value.address,\n                  balance: value.coins,\n                  pubkey: lcdapi_1.normalizePubkey(value.public_key) || undefined,\n                  accountNumber: lcdapi_1.uint64ToNumber(value.account_number),\n                  sequence: lcdapi_1.uint64ToNumber(value.sequence)\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x3) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(height) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(height !== undefined)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.lcdClient.blocks(height);\n\n              case 3:\n                _context6.t0 = _context6.sent;\n                _context6.next = 9;\n                break;\n\n              case 6:\n                _context6.next = 8;\n                return this.lcdClient.blocksLatest();\n\n              case 8:\n                _context6.t0 = _context6.sent;\n\n              case 9:\n                response = _context6.t0;\n                return _context6.abrupt(\"return\", {\n                  id: response.block_id.hash,\n                  header: {\n                    version: response.block.header.version,\n                    time: response.block.header.time,\n                    height: parseInt(response.block.header.height, 10),\n                    chainId: response.block.header.chain_id\n                  },\n                  txs: (response.block.data.txs || []).map(encoding_1.fromBase64)\n                });\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBlock(_x4) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n  }, {\n    key: \"getTx\",\n    value: function () {\n      var _getTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(id) {\n        var _a, results;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.txsQuery(\"tx.hash=\".concat(id));\n\n              case 2:\n                results = _context7.sent;\n                return _context7.abrupt(\"return\", (_a = results[0]) !== null && _a !== void 0 ? _a : null);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getTx(_x5) {\n        return _getTx.apply(this, arguments);\n      }\n\n      return getTx;\n    }()\n  }, {\n    key: \"searchTx\",\n    value: function () {\n      var _searchTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(query) {\n        var filter,\n            minHeight,\n            maxHeight,\n            withFilters,\n            txs,\n            sentQuery,\n            receivedQuery,\n            sent,\n            received,\n            sentHashes,\n            rawQuery,\n            filtered,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                withFilters = function _withFilters(originalQuery) {\n                  return \"\".concat(originalQuery, \"&tx.minheight=\").concat(minHeight, \"&tx.maxheight=\").concat(maxHeight);\n                };\n\n                filter = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                minHeight = filter.minHeight || 0;\n                maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n\n                if (!(maxHeight < minHeight)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", []);\n\n              case 6:\n                if (!isSearchByHeightQuery(query)) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                if (!(query.height < minHeight || query.height > maxHeight)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                txs = [];\n                _context8.next = 14;\n                break;\n\n              case 11:\n                _context8.next = 13;\n                return this.txsQuery(\"tx.height=\".concat(query.height));\n\n              case 13:\n                txs = _context8.sent;\n\n              case 14:\n                _context8.next = 37;\n                break;\n\n              case 16:\n                if (!isSearchBySentFromOrToQuery(query)) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n                sentQuery = withFilters(\"message.module=bank&message.sender=\".concat(query.sentFromOrTo));\n                receivedQuery = withFilters(\"message.module=bank&transfer.recipient=\".concat(query.sentFromOrTo));\n                _context8.next = 21;\n                return this.txsQuery(sentQuery);\n\n              case 21:\n                sent = _context8.sent;\n                _context8.next = 24;\n                return this.txsQuery(receivedQuery);\n\n              case 24:\n                received = _context8.sent;\n                sentHashes = sent.map(function (t) {\n                  return t.hash;\n                });\n                txs = [].concat(_toConsumableArray(sent), _toConsumableArray(received.filter(function (t) {\n                  return !sentHashes.includes(t.hash);\n                })));\n                _context8.next = 37;\n                break;\n\n              case 29:\n                if (!isSearchByTagsQuery(query)) {\n                  _context8.next = 36;\n                  break;\n                }\n\n                rawQuery = withFilters(query.tags.map(function (t) {\n                  return \"\".concat(t.key, \"=\").concat(t.value);\n                }).join(\"&\"));\n                _context8.next = 33;\n                return this.txsQuery(rawQuery);\n\n              case 33:\n                txs = _context8.sent;\n                _context8.next = 37;\n                break;\n\n              case 36:\n                throw new Error(\"Unknown query type\");\n\n              case 37:\n                // backend sometimes messes up with min/max height filtering\n                filtered = txs.filter(function (tx) {\n                  return tx.height >= minHeight && tx.height <= maxHeight;\n                });\n                return _context8.abrupt(\"return\", filtered);\n\n              case 39:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function searchTx(_x6) {\n        return _searchTx.apply(this, arguments);\n      }\n\n      return searchTx;\n    }()\n  }, {\n    key: \"broadcastTx\",\n    value: function () {\n      var _broadcastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(tx) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.lcdClient.broadcastTx(tx);\n\n              case 2:\n                result = _context9.sent;\n\n                if (result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n\n              case 5:\n                return _context9.abrupt(\"return\", result.code !== undefined ? {\n                  height: math_1.Uint53.fromString(result.height).toNumber(),\n                  transactionHash: result.txhash,\n                  code: result.code,\n                  rawLog: result.raw_log || \"\"\n                } : {\n                  logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n                  rawLog: result.raw_log || \"\",\n                  transactionHash: result.txhash,\n                  data: result.data ? encoding_1.fromHex(result.data) : undefined\n                });\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function broadcastTx(_x7) {\n        return _broadcastTx.apply(this, arguments);\n      }\n\n      return broadcastTx;\n    }()\n  }, {\n    key: \"txsQuery\",\n    value: function () {\n      var _txsQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(query) {\n        var limit, result, pages;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                // TODO: we need proper pagination support\n                limit = 100;\n                _context10.next = 3;\n                return this.lcdClient.txsQuery(\"\".concat(query, \"&limit=\").concat(limit));\n\n              case 3:\n                result = _context10.sent;\n                pages = parseInt(result.page_total, 10);\n\n                if (!(pages > 1)) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Found more results on the backend than we can process currently. Results: \".concat(result.total_count, \", supported: \").concat(limit));\n\n              case 7:\n                return _context10.abrupt(\"return\", result.txs.map(function (restItem) {\n                  return {\n                    height: parseInt(restItem.height, 10),\n                    hash: restItem.txhash,\n                    code: restItem.code || 0,\n                    rawLog: restItem.raw_log,\n                    logs: logs_1.parseLogs(restItem.logs || []),\n                    tx: restItem.tx,\n                    timestamp: restItem.timestamp\n                  };\n                }));\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function txsQuery(_x8) {\n        return _txsQuery.apply(this, arguments);\n      }\n\n      return txsQuery;\n    }()\n  }]);\n\n  return CosmosClient;\n}();\n\nexports.CosmosClient = CosmosClient;","map":null,"metadata":{},"sourceType":"script"}