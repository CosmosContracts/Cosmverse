{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmWasmClient = void 0;\n\nvar crypto_1 = require(\"@cosmjs/crypto\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar launchpad_1 = require(\"@cosmjs/launchpad\");\n\nvar math_1 = require(\"@cosmjs/math\");\n\nvar wasm_1 = require(\"./lcdapi/wasm\");\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nvar CosmWasmClient = /*#__PURE__*/function () {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the broadcastTx method returns\n   */\n  function CosmWasmClient(apiUrl) {\n    var broadcastMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : launchpad_1.BroadcastMode.Block;\n\n    _classCallCheck(this, CosmWasmClient);\n\n    this.codesCache = new Map();\n    this.lcdClient = launchpad_1.LcdClient.withExtensions({\n      apiUrl: apiUrl,\n      broadcastMode: broadcastMode\n    }, launchpad_1.setupAuthExtension, wasm_1.setupWasmExtension);\n  }\n\n  _createClass(CosmWasmClient, [{\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, chainId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.chainId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.lcdClient.nodeInfo();\n\n              case 3:\n                response = _context.sent;\n                chainId = response.node_info.network;\n\n                if (chainId) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Chain ID must not be empty\");\n\n              case 7:\n                this.chainId = chainId;\n\n              case 8:\n                return _context.abrupt(\"return\", this.chainId);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getHeight\",\n    value: function () {\n      var _getHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$lcdClient, height, latest;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.anyValidAddress) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.lcdClient.auth.account(this.anyValidAddress);\n\n              case 3:\n                _yield$this$lcdClient = _context2.sent;\n                height = _yield$this$lcdClient.height;\n                return _context2.abrupt(\"return\", parseInt(height, 10));\n\n              case 8:\n                _context2.next = 10;\n                return this.lcdClient.blocksLatest();\n\n              case 10:\n                latest = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(latest.block.header.height, 10));\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getHeight() {\n        return _getHeight.apply(this, arguments);\n      }\n\n      return getHeight;\n    }()\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n\n  }, {\n    key: \"getIdentifier\",\n    value: function () {\n      var _getIdentifier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tx) {\n        var response, hash;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.lcdClient.encodeTx(tx);\n\n              case 2:\n                response = _context3.sent;\n                hash = crypto_1.sha256(encoding_1.fromBase64(response.tx));\n                return _context3.abrupt(\"return\", encoding_1.toHex(hash).toUpperCase());\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getIdentifier(_x) {\n        return _getIdentifier.apply(this, arguments);\n      }\n\n      return getIdentifier;\n    }()\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n\n  }, {\n    key: \"getSequence\",\n    value: function () {\n      var _getSequence = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getAccount(address);\n\n              case 2:\n                account = _context4.sent;\n\n                if (account) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n\n              case 5:\n                return _context4.abrupt(\"return\", {\n                  accountNumber: account.accountNumber,\n                  sequence: account.sequence\n                });\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getSequence(_x2) {\n        return _getSequence.apply(this, arguments);\n      }\n\n      return getSequence;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var account, value;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.lcdClient.auth.account(address);\n\n              case 2:\n                account = _context5.sent;\n                value = account.result.value;\n\n                if (!(value.address === \"\")) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 8:\n                this.anyValidAddress = value.address;\n                return _context5.abrupt(\"return\", {\n                  address: value.address,\n                  balance: value.coins,\n                  pubkey: launchpad_1.normalizePubkey(value.public_key) || undefined,\n                  accountNumber: launchpad_1.uint64ToNumber(value.account_number),\n                  sequence: launchpad_1.uint64ToNumber(value.sequence)\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x3) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(height) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(height !== undefined)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.lcdClient.blocks(height);\n\n              case 3:\n                _context6.t0 = _context6.sent;\n                _context6.next = 9;\n                break;\n\n              case 6:\n                _context6.next = 8;\n                return this.lcdClient.blocksLatest();\n\n              case 8:\n                _context6.t0 = _context6.sent;\n\n              case 9:\n                response = _context6.t0;\n                return _context6.abrupt(\"return\", {\n                  id: response.block_id.hash,\n                  header: {\n                    version: response.block.header.version,\n                    time: response.block.header.time,\n                    height: parseInt(response.block.header.height, 10),\n                    chainId: response.block.header.chain_id\n                  },\n                  txs: (response.block.data.txs || []).map(encoding_1.fromBase64)\n                });\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBlock(_x4) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n  }, {\n    key: \"getTx\",\n    value: function () {\n      var _getTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(id) {\n        var _a, results;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.txsQuery(\"tx.hash=\".concat(id));\n\n              case 2:\n                results = _context7.sent;\n                return _context7.abrupt(\"return\", (_a = results[0]) !== null && _a !== void 0 ? _a : null);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getTx(_x5) {\n        return _getTx.apply(this, arguments);\n      }\n\n      return getTx;\n    }()\n  }, {\n    key: \"searchTx\",\n    value: function () {\n      var _searchTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(query) {\n        var filter,\n            minHeight,\n            maxHeight,\n            withFilters,\n            txs,\n            sentQuery,\n            receivedQuery,\n            _yield$Promise$all,\n            _yield$Promise$all2,\n            sent,\n            received,\n            mergedTxs,\n            next,\n            rawQuery,\n            filtered,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                withFilters = function _withFilters(originalQuery) {\n                  return \"\".concat(originalQuery, \"&tx.minheight=\").concat(minHeight, \"&tx.maxheight=\").concat(maxHeight);\n                };\n\n                filter = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                minHeight = filter.minHeight || 0;\n                maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n\n                if (!(maxHeight < minHeight)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", []);\n\n              case 6:\n                if (!isSearchByHeightQuery(query)) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                if (!(query.height < minHeight || query.height > maxHeight)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                txs = [];\n                _context8.next = 14;\n                break;\n\n              case 11:\n                _context8.next = 13;\n                return this.txsQuery(\"tx.height=\".concat(query.height));\n\n              case 13:\n                txs = _context8.sent;\n\n              case 14:\n                _context8.next = 38;\n                break;\n\n              case 16:\n                if (!isSearchBySentFromOrToQuery(query)) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n                sentQuery = withFilters(\"message.module=bank&message.sender=\".concat(query.sentFromOrTo));\n                receivedQuery = withFilters(\"message.module=bank&transfer.recipient=\".concat(query.sentFromOrTo));\n                _context8.next = 21;\n                return Promise.all([this.txsQuery(sentQuery), this.txsQuery(receivedQuery)]);\n\n              case 21:\n                _yield$Promise$all = _context8.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                sent = _yield$Promise$all2[0];\n                received = _yield$Promise$all2[1];\n                mergedTxs = [];\n                /* eslint-disable @typescript-eslint/no-non-null-assertion */\n                // sent/received are presorted\n\n                while (sent.length && received.length) {\n                  next = sent[0].hash === received[0].hash ? sent.shift() && received.shift() : sent[0].height <= received[0].height ? sent.shift() : received.shift();\n                  mergedTxs = [].concat(_toConsumableArray(mergedTxs), [next]);\n                }\n                /* eslint-enable @typescript-eslint/no-non-null-assertion */\n                // At least one of sent/received is empty by now\n\n\n                txs = [].concat(_toConsumableArray(mergedTxs), _toConsumableArray(sent), _toConsumableArray(received));\n                _context8.next = 38;\n                break;\n\n              case 30:\n                if (!isSearchByTagsQuery(query)) {\n                  _context8.next = 37;\n                  break;\n                }\n\n                rawQuery = withFilters(query.tags.map(function (t) {\n                  return \"\".concat(t.key, \"=\").concat(t.value);\n                }).join(\"&\"));\n                _context8.next = 34;\n                return this.txsQuery(rawQuery);\n\n              case 34:\n                txs = _context8.sent;\n                _context8.next = 38;\n                break;\n\n              case 37:\n                throw new Error(\"Unknown query type\");\n\n              case 38:\n                // backend sometimes messes up with min/max height filtering\n                filtered = txs.filter(function (tx) {\n                  return tx.height >= minHeight && tx.height <= maxHeight;\n                });\n                return _context8.abrupt(\"return\", filtered);\n\n              case 40:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function searchTx(_x6) {\n        return _searchTx.apply(this, arguments);\n      }\n\n      return searchTx;\n    }()\n  }, {\n    key: \"broadcastTx\",\n    value: function () {\n      var _broadcastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(tx) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.lcdClient.broadcastTx(tx);\n\n              case 2:\n                result = _context9.sent;\n\n                if (result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n\n              case 5:\n                return _context9.abrupt(\"return\", result.code !== undefined ? {\n                  height: math_1.Uint53.fromString(result.height).toNumber(),\n                  transactionHash: result.txhash,\n                  code: result.code,\n                  rawLog: result.raw_log || \"\"\n                } : {\n                  logs: result.logs ? launchpad_1.logs.parseLogs(result.logs) : [],\n                  rawLog: result.raw_log || \"\",\n                  transactionHash: result.txhash,\n                  data: result.data ? encoding_1.fromHex(result.data) : undefined\n                });\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function broadcastTx(_x7) {\n        return _broadcastTx.apply(this, arguments);\n      }\n\n      return broadcastTx;\n    }()\n  }, {\n    key: \"getCodes\",\n    value: function () {\n      var _getCodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var _this = this;\n\n        var result;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.lcdClient.wasm.listCodeInfo();\n\n              case 2:\n                result = _context10.sent;\n                return _context10.abrupt(\"return\", result.map(function (entry) {\n                  _this.anyValidAddress = entry.creator;\n                  return {\n                    id: entry.id,\n                    creator: entry.creator,\n                    checksum: encoding_1.toHex(encoding_1.fromHex(entry.data_hash)),\n                    source: entry.source || undefined,\n                    builder: entry.builder || undefined\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getCodes() {\n        return _getCodes.apply(this, arguments);\n      }\n\n      return getCodes;\n    }()\n  }, {\n    key: \"getCodeDetails\",\n    value: function () {\n      var _getCodeDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(codeId) {\n        var cached, getCodeResult, codeDetails;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                cached = this.codesCache.get(codeId);\n\n                if (!cached) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", cached);\n\n              case 3:\n                _context11.next = 5;\n                return this.lcdClient.wasm.getCode(codeId);\n\n              case 5:\n                getCodeResult = _context11.sent;\n                codeDetails = {\n                  id: getCodeResult.id,\n                  creator: getCodeResult.creator,\n                  checksum: encoding_1.toHex(encoding_1.fromHex(getCodeResult.data_hash)),\n                  source: getCodeResult.source || undefined,\n                  builder: getCodeResult.builder || undefined,\n                  data: encoding_1.fromBase64(getCodeResult.data)\n                };\n                this.codesCache.set(codeId, codeDetails);\n                return _context11.abrupt(\"return\", codeDetails);\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getCodeDetails(_x8) {\n        return _getCodeDetails.apply(this, arguments);\n      }\n\n      return getCodeDetails;\n    }()\n  }, {\n    key: \"getContracts\",\n    value: function () {\n      var _getContracts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(codeId) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.lcdClient.wasm.listContractsByCodeId(codeId);\n\n              case 2:\n                result = _context12.sent;\n                return _context12.abrupt(\"return\", result.map(function (entry) {\n                  return {\n                    address: entry.address,\n                    codeId: entry.code_id,\n                    creator: entry.creator,\n                    admin: entry.admin,\n                    label: entry.label\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getContracts(_x9) {\n        return _getContracts.apply(this, arguments);\n      }\n\n      return getContracts;\n    }()\n    /**\n     * Throws an error if no contract was found at the address\n     */\n\n  }, {\n    key: \"getContract\",\n    value: function () {\n      var _getContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(address) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.lcdClient.wasm.getContractInfo(address);\n\n              case 2:\n                result = _context13.sent;\n\n                if (result) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(address, \"\\\"\"));\n\n              case 5:\n                return _context13.abrupt(\"return\", {\n                  address: result.address,\n                  codeId: result.code_id,\n                  creator: result.creator,\n                  admin: result.admin,\n                  label: result.label\n                });\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getContract(_x10) {\n        return _getContract.apply(this, arguments);\n      }\n\n      return getContract;\n    }()\n    /**\n     * Throws an error if no contract was found at the address\n     */\n\n  }, {\n    key: \"getContractCodeHistory\",\n    value: function () {\n      var _getContractCodeHistory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(address) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.lcdClient.wasm.getContractCodeHistory(address);\n\n              case 2:\n                result = _context14.sent;\n\n                if (result) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error(\"No contract history found for address \\\"\".concat(address, \"\\\"\"));\n\n              case 5:\n                return _context14.abrupt(\"return\", result.map(function (entry) {\n                  return {\n                    operation: entry.operation,\n                    codeId: entry.code_id,\n                    msg: entry.msg\n                  };\n                }));\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getContractCodeHistory(_x11) {\n        return _getContractCodeHistory.apply(this, arguments);\n      }\n\n      return getContractCodeHistory;\n    }()\n    /**\n     * Returns the data at the key if present (raw contract dependent storage data)\n     * or null if no data at this key.\n     *\n     * Promise is rejected when contract does not exist.\n     */\n\n  }, {\n    key: \"queryContractRaw\",\n    value: function () {\n      var _queryContractRaw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(address, key) {\n        var _info;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.getContract(address);\n\n              case 2:\n                _info = _context15.sent;\n                return _context15.abrupt(\"return\", this.lcdClient.wasm.queryContractRaw(address, key));\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function queryContractRaw(_x12, _x13) {\n        return _queryContractRaw.apply(this, arguments);\n      }\n\n      return queryContractRaw;\n    }()\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     */\n\n  }, {\n    key: \"queryContractSmart\",\n    value: function () {\n      var _queryContractSmart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(address, queryMsg) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.prev = 0;\n                _context16.next = 3;\n                return this.lcdClient.wasm.queryContractSmart(address, queryMsg);\n\n              case 3:\n                return _context16.abrupt(\"return\", _context16.sent);\n\n              case 6:\n                _context16.prev = 6;\n                _context16.t0 = _context16[\"catch\"](0);\n\n                if (!(_context16.t0 instanceof Error)) {\n                  _context16.next = 16;\n                  break;\n                }\n\n                if (!_context16.t0.message.startsWith(\"not found: contract\")) {\n                  _context16.next = 13;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(address, \"\\\"\"));\n\n              case 13:\n                throw _context16.t0;\n\n              case 14:\n                _context16.next = 17;\n                break;\n\n              case 16:\n                throw _context16.t0;\n\n              case 17:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[0, 6]]);\n      }));\n\n      function queryContractSmart(_x14, _x15) {\n        return _queryContractSmart.apply(this, arguments);\n      }\n\n      return queryContractSmart;\n    }()\n  }, {\n    key: \"txsQuery\",\n    value: function () {\n      var _txsQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(query) {\n        var limit, result, pages;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                // TODO: we need proper pagination support\n                limit = 100;\n                _context17.next = 3;\n                return this.lcdClient.txsQuery(\"\".concat(query, \"&limit=\").concat(limit));\n\n              case 3:\n                result = _context17.sent;\n                pages = parseInt(result.page_total, 10);\n\n                if (!(pages > 1)) {\n                  _context17.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Found more results on the backend than we can process currently. Results: \".concat(result.total_count, \", supported: \").concat(limit));\n\n              case 7:\n                return _context17.abrupt(\"return\", result.txs.map(function (restItem) {\n                  return {\n                    height: parseInt(restItem.height, 10),\n                    hash: restItem.txhash,\n                    code: restItem.code || 0,\n                    rawLog: restItem.raw_log,\n                    logs: launchpad_1.logs.parseLogs(restItem.logs || []),\n                    tx: restItem.tx,\n                    timestamp: restItem.timestamp\n                  };\n                }));\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function txsQuery(_x16) {\n        return _txsQuery.apply(this, arguments);\n      }\n\n      return txsQuery;\n    }()\n  }]);\n\n  return CosmWasmClient;\n}();\n\nexports.CosmWasmClient = CosmWasmClient;","map":null,"metadata":{},"sourceType":"script"}