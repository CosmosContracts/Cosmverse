{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar long_1 = __importDefault(require(\"long\"));\n/**\n * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.\n * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.\n * The result is typically 20 bytes long but not restricted to that.\n */\n\n\nfunction toAccAddress(address) {\n  return encoding_1.Bech32.decode(address).data;\n}\n\nexports.toAccAddress = toAccAddress;\n\nfunction createPagination(paginationKey) {\n  return paginationKey ? {\n    key: paginationKey,\n    offset: long_1.default.fromNumber(0, true),\n    limit: long_1.default.fromNumber(0, true),\n    countTotal: false\n  } : undefined;\n}\n\nexports.createPagination = createPagination;\n\nfunction createProtobufRpcClient(base) {\n  return {\n    request: function request(service, method, data) {\n      var path = \"/\".concat(service, \"/\").concat(method);\n      return base.queryUnverified(path, data);\n    }\n  };\n}\n\nexports.createProtobufRpcClient = createProtobufRpcClient;","map":null,"metadata":{},"sourceType":"script"}