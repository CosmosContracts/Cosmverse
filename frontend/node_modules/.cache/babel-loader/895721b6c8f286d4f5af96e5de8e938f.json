{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\n\nvar long_1 = __importDefault(require(\"long\"));\n\nvar minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nvar channel_1 = require(\"../../../../ibc/core/channel/v1/channel\");\n\nvar client_1 = require(\"../../../../ibc/core/client/v1/client\");\n\nexports.protobufPackage = \"ibc.core.channel.v1\";\nvar baseMsgChannelOpenInit = {\n  portId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenInit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenInit);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelOpenInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelOpenInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelOpenInitResponse = {};\nexports.MsgChannelOpenInitResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenInitResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    return message;\n  }\n};\nvar baseMsgChannelOpenTry = {\n  portId: \"\",\n  previousChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenTry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.previousChannelId !== \"\") {\n      writer.uint32(18).string(message.previousChannelId);\n    }\n\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(42).bytes(message.proofInit);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.previousChannelId = reader.string();\n          break;\n\n        case 3:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n\n        case 5:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = String(object.previousChannelId);\n    } else {\n      message.previousChannelId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelOpenTry);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = object.previousChannelId;\n    } else {\n      message.previousChannelId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelOpenTryResponse = {};\nexports.MsgChannelOpenTryResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenTryResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  }\n};\nvar baseMsgChannelOpenAck = {\n  portId: \"\",\n  channelId: \"\",\n  counterpartyChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenAck = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.counterpartyChannelId !== \"\") {\n      writer.uint32(26).string(message.counterpartyChannelId);\n    }\n\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n\n    if (message.proofTry.length !== 0) {\n      writer.uint32(42).bytes(message.proofTry);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.counterpartyChannelId = reader.string();\n          break;\n\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n\n        case 5:\n          message.proofTry = reader.bytes();\n          break;\n\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = String(object.counterpartyChannelId);\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = bytesFromBase64(object.proofTry);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.counterpartyChannelId !== undefined && (obj.counterpartyChannelId = message.counterpartyChannelId);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelOpenAck);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = object.counterpartyChannelId;\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = object.proofTry;\n    } else {\n      message.proofTry = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelOpenAckResponse = {};\nexports.MsgChannelOpenAckResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenAckResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  }\n};\nvar baseMsgChannelOpenConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenConfirm = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.proofAck.length !== 0) {\n      writer.uint32(26).bytes(message.proofAck);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.proofAck = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = bytesFromBase64(object.proofAck);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelOpenConfirm);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = object.proofAck;\n    } else {\n      message.proofAck = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelOpenConfirmResponse = {};\nexports.MsgChannelOpenConfirmResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  }\n};\nvar baseMsgChannelCloseInit = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseInit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelCloseInit);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelCloseInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelCloseInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelCloseInitResponse = {};\nexports.MsgChannelCloseInitResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelCloseInitResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  }\n};\nvar baseMsgChannelCloseConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseConfirm = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(26).bytes(message.proofInit);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgChannelCloseConfirm);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgChannelCloseConfirmResponse = {};\nexports.MsgChannelCloseConfirmResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  }\n};\nvar baseMsgRecvPacket = {\n  signer: \"\"\n};\nexports.MsgRecvPacket = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofCommitment.length !== 0) {\n      writer.uint32(18).bytes(message.proofCommitment);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofCommitment = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = bytesFromBase64(object.proofCommitment);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofCommitment !== undefined && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgRecvPacket);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = object.proofCommitment;\n    } else {\n      message.proofCommitment = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgRecvPacketResponse = {};\nexports.MsgRecvPacketResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgRecvPacketResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgRecvPacketResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgRecvPacketResponse);\n    return message;\n  }\n};\nvar baseMsgTimeout = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeout = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(32).uint64(message.nextSequenceRecv);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgTimeout);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgTimeoutResponse = {};\nexports.MsgTimeoutResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgTimeoutResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgTimeoutResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgTimeoutResponse);\n    return message;\n  }\n};\nvar baseMsgTimeoutOnClose = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeoutOnClose = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n\n    if (message.proofClose.length !== 0) {\n      writer.uint32(26).bytes(message.proofClose);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(40).uint64(message.nextSequenceRecv);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(50).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n\n        case 3:\n          message.proofClose = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n\n        case 6:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = bytesFromBase64(object.proofClose);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofClose !== undefined && (obj.proofClose = base64FromBytes(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgTimeoutOnClose);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = object.proofClose;\n    } else {\n      message.proofClose = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgTimeoutOnCloseResponse = {};\nexports.MsgTimeoutOnCloseResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    return message;\n  }\n};\nvar baseMsgAcknowledgement = {\n  signer: \"\"\n};\nexports.MsgAcknowledgement = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.acknowledgement.length !== 0) {\n      writer.uint32(18).bytes(message.acknowledgement);\n    }\n\n    if (message.proofAcked.length !== 0) {\n      writer.uint32(26).bytes(message.proofAcked);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.acknowledgement = reader.bytes();\n          break;\n\n        case 3:\n          message.proofAcked = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = bytesFromBase64(object.acknowledgement);\n    }\n\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = bytesFromBase64(object.proofAcked);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.acknowledgement !== undefined && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));\n    message.proofAcked !== undefined && (obj.proofAcked = base64FromBytes(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var message = Object.assign({}, baseMsgAcknowledgement);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = object.acknowledgement;\n    } else {\n      message.acknowledgement = new Uint8Array();\n    }\n\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = object.proofAcked;\n    } else {\n      message.proofAcked = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n};\nvar baseMsgAcknowledgementResponse = {};\nexports.MsgAcknowledgementResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgAcknowledgementResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgAcknowledgementResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgAcknowledgementResponse);\n    return message;\n  }\n};\n\nvar MsgClientImpl = /*#__PURE__*/function () {\n  function MsgClientImpl(rpc) {\n    _classCallCheck(this, MsgClientImpl);\n\n    this.rpc = rpc;\n  }\n\n  _createClass(MsgClientImpl, [{\n    key: \"ChannelOpenInit\",\n    value: function ChannelOpenInit(request) {\n      var data = exports.MsgChannelOpenInit.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenInit\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenTry\",\n    value: function ChannelOpenTry(request) {\n      var data = exports.MsgChannelOpenTry.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenTry\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenAck\",\n    value: function ChannelOpenAck(request) {\n      var data = exports.MsgChannelOpenAck.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenAck\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelOpenConfirm\",\n    value: function ChannelOpenConfirm(request) {\n      var data = exports.MsgChannelOpenConfirm.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenConfirm\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelCloseInit\",\n    value: function ChannelCloseInit(request) {\n      var data = exports.MsgChannelCloseInit.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseInit\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ChannelCloseConfirm\",\n    value: function ChannelCloseConfirm(request) {\n      var data = exports.MsgChannelCloseConfirm.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseConfirm\", data);\n      return promise.then(function (data) {\n        return exports.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"RecvPacket\",\n    value: function RecvPacket(request) {\n      var data = exports.MsgRecvPacket.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"RecvPacket\", data);\n      return promise.then(function (data) {\n        return exports.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Timeout\",\n    value: function Timeout(request) {\n      var data = exports.MsgTimeout.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Timeout\", data);\n      return promise.then(function (data) {\n        return exports.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"TimeoutOnClose\",\n    value: function TimeoutOnClose(request) {\n      var data = exports.MsgTimeoutOnClose.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"TimeoutOnClose\", data);\n      return promise.then(function (data) {\n        return exports.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"Acknowledgement\",\n    value: function Acknowledgement(request) {\n      var data = exports.MsgAcknowledgement.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Acknowledgement\", data);\n      return promise.then(function (data) {\n        return exports.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }]);\n\n  return MsgClientImpl;\n}();\n\nexports.MsgClientImpl = MsgClientImpl;\n\nvar globalThis = function () {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n}();\n\nvar atob = globalThis.atob || function (b64) {\n  return globalThis.Buffer.from(b64, \"base64\").toString(\"binary\");\n};\n\nfunction bytesFromBase64(b64) {\n  var bin = atob(b64);\n  var arr = new Uint8Array(bin.length);\n\n  for (var i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nvar btoa = globalThis.btoa || function (bin) {\n  return globalThis.Buffer.from(bin, \"binary\").toString(\"base64\");\n};\n\nfunction base64FromBytes(arr) {\n  var bin = [];\n\n  for (var i = 0; i < arr.byteLength; ++i) {\n    bin.push(String.fromCharCode(arr[i]));\n  }\n\n  return btoa(bin.join(\"\"));\n}\n\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":null,"metadata":{},"sourceType":"script"}